<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üòº Kambot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 280px;
            background: #202123;
            border-right: 1px solid #363739;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            position: fixed; /* Change to fixed positioning */
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3); /* Add shadow for better visibility */
        }
        
        .sidebar.collapsed {
            margin-left: -280px;
        }
        
        .sidebar-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: #2a2b2e;
            border: 1px solid #404142;
            border-radius: 8px;
            color: #ffffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .sidebar-toggle:hover {
            background: #353639;
            border-color: #565760;
        }
        
        .sidebar-toggle.sidebar-open {
            left: 300px;
        }
        
        .sidebar-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .sidebar-header h1 {
            font-size: 24px;
            font-weight: 600;
            color: #ffffff;
        }
        
        .model-section {
            background: #2a2b2e;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #404142;
        }
        
        .model-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .model-select {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #404142;
            border-radius: 8px;
            color: #ffffff;
            padding: 10px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .model-select:hover {
            border-color: #10a37f;
            background: #1e1e1e;
        }
        
        .model-select:focus {
            outline: none;
            border-color: #10a37f;
            box-shadow: 0 0 0 3px rgba(16, 163, 127, 0.1);
        }
        
        .model-info {
            font-size: 12px;
            color: #8e8ea0;
            margin-top: 8px;
        }
        
        .sidebar-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .sidebar-button {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #404142;
            border-radius: 8px;
            background: #2a2b2e;
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .button-status {
            font-size: 12px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            min-width: 30px;
            text-align: center;
        }
        
        .status-on {
            background: #22c55e;
            color: #ffffff;
        }
        
        .status-off {
            background: #ef4444;
            color: #ffffff;
        }
        
        .sidebar-button:hover {
            background: #353639;
            border-color: #565760;
        }
        
        .sidebar-button:active {
            transform: translateY(1px);
        }
        
        .sidebar-button.danger {
            border-color: #d73a49;
            color: #ff6b6b;
        }
        
        .sidebar-button.danger:hover {
            background: #2d1b1f;
            border-color: #ff6b6b;
        }
        
        .sidebar-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* Donation Section */
        .donation-section {
            background: #2a2b2e;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #404142;
            margin-top: auto;
        }
        
        .donation-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .donation-section p {
            font-size: 12px;
            color: #8e8ea0;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        .donation-section a {
            color: #10a37f;
            text-decoration: none;
            font-weight: 500;
        }
        
        .donation-section a:hover {
            color: #0d8f6a;
            text-decoration: underline;
        }
        
        /* Footer Section */
        .sidebar-footer {
            border-top: 1px solid #404142;
            padding-top: 16px;
            margin-top: 16px;
            text-align: center;
        }
        
        .sidebar-footer .creator {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 4px;
        }
        
        .sidebar-footer .powered-by {
            font-size: 12px;
            color: #8e8ea0;
        }
        
        /* Custom Modal Styles */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .custom-modal.show {
            display: flex;
        }
        
        .modal-content {
            background: #2a2b2e;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #404142;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modal-message {
            font-size: 14px;
            color: #8e8ea0;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .modal-button {
            padding: 10px 20px;
            border: 1px solid #404142;
            border-radius: 8px;
            background: #2a2b2e;
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .modal-button:hover {
            background: #353639;
            border-color: #565760;
        }
        
        .modal-button.danger {
            border-color: #d73a49;
            color: #ff6b6b;
        }
        
        .modal-button.danger:hover {
            background: #2d1b1f;
            border-color: #ff6b6b;
        }
        
        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #212121;
            height: 100vh;
            transition: margin-left 0.3s ease;
        }
        
        .main-content.sidebar-collapsed {
            margin-left: -100px; /* Reduced from -280px to make it less obstructive */
        }
        
        /* Add overlay effect when sidebar is open */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 999;
            display: none;
            transition: opacity 0.3s ease;
        }
        
        .sidebar-overlay.show {
            display: block;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 50%;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            gap: 20px;
            padding-top: 80px;
            height: 100vh; /* Add explicit height */
            overflow: hidden; /* Prevent container overflow */
        }
        
        .chat-history {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scroll */
            padding: 20px;
            background: #2a2a2a;
            border-radius: 12px;
            border: 1px solid #404040;
            position: relative;
            min-height: 0; /* Allow flex shrinking */
        }
        
        .message {
            margin-bottom: 20px;
            padding: 16px;
            border-radius: 12px;
            position: relative;
            max-width: 85%;
            word-wrap: break-word;
        }
        
        .user-message {
            background: linear-gradient(135deg, #10a37f, #0d8f6a);
            margin-left: auto;
            color: #ffffff;
            box-shadow: 0 2px 10px rgba(16, 163, 127, 0.3);
        }
        
        .bot-message {
            background: #363636;
            border: 1px solid #505050;
            color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .message-role {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }
        
        .message-content {
            line-height: 1.6;
            font-size: 15px;
            white-space: pre-wrap;
        }
        
        /* Formatting styles for bot messages */
        .message-content strong {
            font-weight: 700;
            color: #ffffff;
        }
        
        .message-content em {
            font-style: italic;
            color: #e0e0e0;
        }
        
        .message-content .color-red { color: #ff6b6b; }
        .message-content .color-green { color: #51cf66; }
        .message-content .color-blue { color: #74c0fc; }
        .message-content .color-yellow { color: #ffd43b; }
        .message-content .color-purple { color: #d084ff; }
        .message-content .color-orange { color: #ff922b; }
        .message-content .color-pink { color: #ffa8cc; }
        .message-content .color-cyan { color: #74e6e6; }
        .message-content .color-lime { color: #c9ff74; }
        .message-content .color-teal { color: #66d9ef; }
        
        .input-area {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #404040;
        }
        
        .input-row {
            display: flex;
            align-items: flex-end;
            gap: 12px;
        }
        
        textarea {
            flex: 1;
            padding: 16px;
            border: 1px solid #404040;
            border-radius: 10px;
            font-size: 16px;
            background: #1a1a1a;
            color: #ffffff;
            resize: none;
            min-height: 56px;
            max-height: 150px;
            line-height: 1.5;
            font-family: inherit;
            transition: border-color 0.2s ease;
        }
        
        textarea:focus {
            outline: none;
            border-color: #10a37f;
            box-shadow: 0 0 0 3px rgba(16, 163, 127, 0.1);
        }
        
        textarea::placeholder {
            color: #8e8ea0;
        }
        
        .send-button {
            padding: 16px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(135deg, #10a37f, #0d8f6a);
            color: #ffffff;
            box-shadow: 0 2px 10px rgba(16, 163, 127, 0.3);
            min-width: 100px;
        }
        
        .send-button:hover {
            background: linear-gradient(135deg, #0d8f6a, #0a7356);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(16, 163, 127, 0.4);
        }
        
        .send-button:active {
            transform: translateY(0);
        }
        
        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .loading {
            background: #2c8c44;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .spinner {
            display: none;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }
        
        .loading .spinner {
            display: inline-block;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #thinking-indicator {
            display: none;
            margin-top: 15px;
            text-align: center;
            font-style: italic;
            color: #8e8ea0;
            font-size: 14px;
        }
        
        .typing {
            display: inline-block;
            animation: blink 0.7s infinite;
        }
        
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #505050;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #606060;
        }
        
        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: #505050 #2a2a2a;
        }
        
        /* Welcome message for empty chat */
        .welcome-message {
            text-align: center;
            color: #8e8ea0;
            font-size: 16px;
            margin-top: 50px;
        }
        
        .welcome-message h2 {
            color: #ffffff;
            margin-bottom: 10px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto; /* Allow scrolling on mobile */
            }
            
            .sidebar {
                width: 100vw;
                height: 100vh;
                padding: 15px;
                border-right: none;
                border-bottom: none;
                margin-left: 0;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 1001;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                overflow-y: auto; /* Enable scrolling in sidebar */
            }
            
            .sidebar.collapsed {
                margin-left: 0;
                margin-top: 0;
                transform: translateX(-100%);
            }
            
            .sidebar:not(.collapsed) {
                transform: translateX(0);
            }
            
            .sidebar-toggle {
                top: 15px;
                left: 15px;
                z-index: 1002;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            .sidebar-toggle.sidebar-open {
                left: 15px;
                top: 15px;
                background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
                border-color: #ff6b6b;
            }
            
            .sidebar-overlay {
                z-index: 1000;
            }
            
            .main-content {
                height: 100vh;
                margin-left: 0;
                margin-top: 0;
                overflow: auto; /* Allow scrolling in main content */
            }
            
            .main-content.sidebar-collapsed {
                margin-left: 0;
                margin-top: 0;
                height: 100vh;
            }
            
            .chat-container {
                max-width: 100%;
                padding: 15px;
                padding-top: 70px;
                gap: 15px;
                height: auto; /* Remove fixed height on mobile */
                min-height: calc(100vh - 30px); /* Ensure full height */
                overflow: visible; /* Allow natural overflow on mobile */
            }
            
            .chat-history {
                padding: 15px;
                height: auto; /* Remove fixed height */
                min-height: 300px; /* Minimum height for chat area */
                overflow-y: auto; /* Enable scrolling */
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            }
            
            .message {
                max-width: 100%;
                padding: 12px;
            }
            
            .input-area {
                padding: 15px;
                position: relative; /* Remove fixed positioning */
            }
            
            textarea {
                min-height: 50px;
                max-height: 120px;
                padding: 12px;
                font-size: 16px;
                -webkit-appearance: none; /* Remove iOS styling */
                appearance: none; /* Remove default styling */
            }
            
            textarea::placeholder {
                font-size: 14px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .send-button {
                padding: 12px 20px;
                min-width: 80px;
                font-size: 14px;
            }
            
            .sidebar-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .sidebar-button {
                padding: 14px 16px;
                font-size: 16px;
            }
            
            .donation-section {
                margin-top: 15px;
                padding: 12px;
            }
            
            .donation-section p {
                font-size: 13px;
            }
            
            .sidebar-footer {
                padding: 12px;
                margin-top: 12px;
            }
            
            .modal-content {
                margin: 15px;
                width: calc(100% - 30px);
                max-width: none;
            }
        }
        
        /* Additional mobile-specific fixes */
        @media (max-width: 480px) {
            .chat-container {
                padding: 10px;
                padding-top: 65px;
                padding-bottom: 20px; /* Add bottom padding */
                height: auto; /* Ensure mobile gets auto height */
                overflow: visible; /* Allow natural overflow */
            }
            
            .sidebar-header h1 {
                font-size: 20px;
            }
            
            .model-section, .donation-section {
                padding: 12px;
            }
            
            textarea::placeholder {
                content: "Type message...";
            }
            
            /* Ensure proper touch scrolling */
            .chat-history {
                -webkit-overflow-scrolling: touch;
                touch-action: pan-y;
            }
        }
        
        /* Reasoning/Thinking Styles */
        .thinking-section {
            margin: 10px 0;
        }
        
        .thinking-toggle {
            width: 24px;
            height: 24px;
            background: #2a2b2e;
            border: 1px solid #404040;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #ffffff;
            transition: all 0.2s ease;
            margin-bottom: 5px;
        }
        
        .thinking-toggle:hover {
            background: #333333;
            border-color: #565760;
            color: #ffffff;
        }
        
        .thinking-caret {
            transition: transform 0.2s ease;
            font-size: 14px;
            color: #ffffff !important;
            user-select: none;
            display: inline-block;
            font-weight: bold;
        }
        
        .thinking-caret.expanded {
            transform: rotate(90deg);
        }
        
        .thinking-content {
            margin-top: 8px;
            font-size: 13px;
            line-height: 1.5;
            color: #b0b0b0;
            white-space: pre-wrap;
            background: #1e1e1e;
            border: 1px solid #404040;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.3s ease;
            opacity: 0;
            max-height: 0;
            padding: 0 12px;
        }
        
        .thinking-content.expanded {
            opacity: 1;
            max-height: 500px;
            padding: 12px;
        }
        
        /* Split Button Styles */
        .split-button-container {
            display: flex;
            gap: 0;
        }
        
        .split-button {
            flex: 1;
            margin: 0;
            justify-content: center;
        }
        
        .split-button.left {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
        }
        
        .split-button.right {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left: 1px solid #404142;
        }
        
        .split-button:hover {
            z-index: 1;
            position: relative;
        }

    </style>
</head>
<body>
    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebar-toggle">‚ò∞</button>
    
    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h1>üòº Kambot</h1>
        </div>
        
        <div class="model-section">
            <h3>ü§ñ Models</h3>
            <select class="model-select" id="model-select">
                {% for model_id, model_info in available_models.items() %}
                    <option value="{{ model_id }}" {% if model_id == current_model %}selected{% endif %}>
                        {{ model_info.name }}
                    </option>
                {% endfor %}
            </select>
            <div class="model-info" id="model-info">
                Choose the AI model that best fits your needs
            </div>
        </div>
        
        <div class="sidebar-buttons">
            <button class="sidebar-button" id="copy-chat-button">
                üìã Copy Chat
            </button>
            <div class="split-button-container">
                <button class="sidebar-button split-button left" id="undo-button">
                    ‚Ü∂ Undo
                </button>
                <button class="sidebar-button split-button right" id="redo-button">
                    ‚Ü∑ Redo
                </button>
            </div>
            <div class="split-button-container">
                <button class="sidebar-button split-button left" id="emoji-toggle-button">
                    <span>üòä Emojis</span>
                    <span class="button-status status-on" id="emoji-status">ON</span>
                </button>
                <button class="sidebar-button split-button right" id="color-toggle-button">
                    <span>üåà Colors</span>
                    <span class="button-status status-on" id="color-status">ON</span>
                </button>
            </div>
            <div class="split-button-container">
                <button class="sidebar-button split-button left" id="bold-toggle-button">
                    <span><strong>B</strong> Bold</span>
                    <span class="button-status status-on" id="bold-status">ON</span>
                </button>
                <button class="sidebar-button split-button right" id="italic-toggle-button">
                    <span><em>I</em> Italics</span>
                    <span class="button-status status-on" id="italic-status">ON</span>
                </button>
            </div>
            <button class="sidebar-button danger" id="clear-button">
                üóëÔ∏è Clear Chat
            </button>
        </div>
        
        <div class="donation-section">
            <h3>üíù Support</h3>
            <p>Note: Private and uncensored. Chats will not save due to the inpersistent state of the server. Render.com is graciously hosting our web app for free, so it spins down with inactivity. Please use the 'Copy Chat' button to save the chat to your clipboard and paste it somewhere to save for now. This app does not require payment and has no ads. A donation would help and possibly one day our server instance can be upgraded! Here is a secure Stripe link to donate directly to me, which would support and validate my work:</p>
            <p><a href="https://donate.stripe.com/3cs8zU2CPecAfw4eUU" target="_blank">Donate</a></p>
            <p>Thank you,<br>-Kameon</p>
        </div>
        
        <div class="sidebar-footer">
            <div class="creator">Kameon</div>
            <div class="powered-by">Powered by Venice</div>
        </div>
    </div>
    
    <!-- Main Chat Area -->
    <div class="main-content" id="main-content">
        <div class="chat-container">
            <div class="chat-history" id="chat-history">
                {% if chat_history %}
                    {% for message in chat_history %}
                        <div class="message {% if message.role == 'user' %}user-message{% else %}bot-message{% endif %}">
                            <div class="message-role">{{ "You" if message.role == 'user' else "Kambot" }}</div>
                            {% if message.role != 'user' and '<think>' in message.content %}
                                {% set thinking_matches = message.content | regex_findall('<think>(.*?)</think>', dotall=True) %}
                                {% set main_content = message.content | regex_sub('<think>.*?</think>', '', dotall=True) | trim %}
                                {% if thinking_matches %}
                                    <div class="thinking-section">
                                        <div class="thinking-toggle" onclick="toggleThinking(this)">
                                            <span class="thinking-caret">‚ñ∂</span>
                                        </div>
                                        <div class="thinking-content">{{ thinking_matches | join('\n') }}</div>
                                    </div>
                                {% endif %}
                                <div class="message-content" data-formatted="true">{{ main_content }}</div>
                            {% else %}
                                {% if message.role == 'user' %}
                                    <div class="message-content">{{ message.content }}</div>
                                {% else %}
                                    <div class="message-content" data-formatted="true">{{ message.content }}</div>
                                {% endif %}
                            {% endif %}
                        </div>
                    {% endfor %}
                {% else %}
                    <div class="welcome-message" id="welcome-message">
                        <h2>Welcome to Kambot! üòº</h2>
                        <p>Hey there! I'm Kambot, your AI assistant üò∏. What can I help you with today?</p>
                    </div>
                {% endif %}
                <div id="thinking-indicator">
                    Kambot is thinking<span class="typing">...</span>
                </div>
            </div>
            
            <form method="POST" class="input-area" id="chat-form">
                <div class="input-row">
                    <textarea name="user_query" placeholder="Type your message here... (Press Enter to send)" required autofocus rows="1"></textarea>
                    <button type="submit" class="send-button" id="send-button">
                        <span id="button-text">Send</span>
                        <span class="spinner" id="button-spinner"></span>
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Custom Modal for Clear Chat Confirmation -->
    <div class="custom-modal" id="clear-modal">
        <div class="modal-content">
            <div class="modal-title">
                üóëÔ∏è Clear Chat History
            </div>
            <div class="modal-message">
                Are you sure you want to clear the entire chat history? This action cannot be undone.
            </div>
            <div class="modal-buttons">
                <button class="modal-button" id="cancel-clear">Cancel</button>
                <button class="modal-button danger" id="confirm-clear">Clear Chat</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const chatHistory = document.querySelector('.chat-history');
            const chatForm = document.getElementById('chat-form');
            const textarea = document.querySelector('textarea');
            const button = document.getElementById('send-button');
            const buttonText = document.getElementById('button-text');
            const spinner = document.getElementById('button-spinner');
            const thinkingIndicator = document.getElementById('thinking-indicator');
            const clearButton = document.getElementById('clear-button');
            const copyChatButton = document.getElementById('copy-chat-button');
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            const modelSelect = document.getElementById('model-select');
            const modelInfo = document.getElementById('model-info');
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const clearModal = document.getElementById('clear-modal');
            const cancelClear = document.getElementById('cancel-clear');
            const confirmClear = document.getElementById('confirm-clear');
            const emojiToggleButton = document.getElementById('emoji-toggle-button');
            const colorToggleButton = document.getElementById('color-toggle-button');
            const boldToggleButton = document.getElementById('bold-toggle-button');
            const italicToggleButton = document.getElementById('italic-toggle-button');
            
            // Get status indicators
            const emojiStatus = document.getElementById('emoji-status');
            const colorStatus = document.getElementById('color-status');
            const boldStatus = document.getElementById('bold-status');
            const italicStatus = document.getElementById('italic-status');
            
            // Initialize formatting states from server with better error handling
            let emojisEnabled = true;
            let colorsEnabled = true;
            let boldEnabled = true;
            let italicsEnabled = true;
            
            // Check if formatting_settings exists and parse safely
            try {
                const serverSettings = JSON.parse('{{ (formatting_settings|tojson) if formatting_settings else "{}" }}');
                
                if (serverSettings && Object.keys(serverSettings).length > 0) {
                    emojisEnabled = serverSettings.emojis_enabled !== undefined ? serverSettings.emojis_enabled : emojisEnabled;
                    colorsEnabled = serverSettings.colors_enabled !== undefined ? serverSettings.colors_enabled : colorsEnabled;
                    boldEnabled = serverSettings.bold_enabled !== undefined ? serverSettings.bold_enabled : boldEnabled;
                    italicsEnabled = serverSettings.italics_enabled !== undefined ? serverSettings.italics_enabled : italicsEnabled;
                    
                    console.log('Loaded server formatting settings:', serverSettings);
                } else {
                    console.log('No formatting settings from server, using defaults');
                }
            } catch (e) {
                console.error('Failed to parse server formatting settings:', e);
                console.log('Using default formatting settings');
            }
            
            // Initialize button states on page load
            function initializeButtonStates() {
                if (emojiStatus) updateStatusIndicator(emojiStatus, emojisEnabled);
                if (colorStatus) updateStatusIndicator(colorStatus, colorsEnabled);
                if (boldStatus) updateStatusIndicator(boldStatus, boldEnabled);
                if (italicStatus) updateStatusIndicator(italicStatus, italicsEnabled);
                
                console.log('Button states initialized:', {
                    emojis: emojisEnabled,
                    colors: colorsEnabled,
                    bold: boldEnabled,
                    italics: italicsEnabled
                });
            }
            
            // Call initialization
            initializeButtonStates();
            
            // Sidebar toggle functionality - Start with sidebar closed
            let sidebarOpen = false;
            
            // Get overlay element
            const sidebarOverlay = document.getElementById('sidebar-overlay');
            
            // Set initial state properly - sidebar should be collapsed by default
            sidebar.classList.add('collapsed');
            mainContent.classList.add('sidebar-collapsed');
            sidebarToggle.innerHTML = '‚ò∞';
            
            sidebarToggle.addEventListener('click', function() {
                console.log('Toggle clicked, current state:', sidebarOpen); // Debug log
                sidebarOpen = !sidebarOpen;
                
                if (sidebarOpen) {
                    console.log('Opening sidebar'); // Debug log
                    sidebar.classList.remove('collapsed');
                    mainContent.classList.remove('sidebar-collapsed');
                    mainContent.classList.add('sidebar-open');
                    sidebarOverlay.classList.add('show');
                    sidebarToggle.classList.add('sidebar-open');
                    sidebarToggle.innerHTML = '‚úñ';
                } else {
                    console.log('Closing sidebar'); // Debug log
                    sidebar.classList.add('collapsed');
                    mainContent.classList.remove('sidebar-open');
                    mainContent.classList.add('sidebar-collapsed');
                    sidebarOverlay.classList.remove('show');
                    sidebarToggle.classList.remove('sidebar-open');
                    sidebarToggle.innerHTML = '‚ò∞';
                }
            });
            
            // Close sidebar when clicking overlay
            sidebarOverlay.addEventListener('click', function() {
                if (sidebarOpen) {
                    sidebarToggle.click(); // Trigger the toggle to close
                }
            });
            
            // Model selection
            modelSelect.addEventListener('change', function() {
                const selectedModel = this.value;
                const originalInfo = modelInfo.textContent;
                modelInfo.textContent = 'Updating model...';
                
                fetch('/set_model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ model_id: selectedModel })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        modelInfo.textContent = `Using ${this.options[this.selectedIndex].text}`;
                        
                        // Show a brief notification that formatting settings will apply to next messages
                        const tempNotification = document.createElement('div');
                        tempNotification.style.cssText = `
                            position: fixed;
                            top: 80px;
                            right: 20px;
                            background: #10a37f;
                            color: white;
                            padding: 12px 16px;
                            border-radius: 8px;
                            font-size: 14px;
                            z-index: 1001;
                            opacity: 0;
                            transition: opacity 0.3s ease;
                        `;
                        tempNotification.textContent = 'Model updated! Formatting settings will apply to new messages.';
                        document.body.appendChild(tempNotification);
                        
                        // Animate in
                        setTimeout(() => tempNotification.style.opacity = '1', 10);
                        
                        // Remove after 3 seconds
                        setTimeout(() => {
                            tempNotification.style.opacity = '0';
                            setTimeout(() => tempNotification.remove(), 300);
                        }, 3000);
                        
                    } else {
                        modelInfo.textContent = originalInfo;
                        console.error('Failed to update model:', data.error);
                    }
                })
                .catch(error => {
                    modelInfo.textContent = originalInfo;
                    console.error('Error updating model:', error);
                });
            });
            
            // Undo functionality
            undoButton.addEventListener('click', function() {
                fetch('/undo', {
                    method: 'POST',
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        window.location.reload(); // Refresh to show updated chat
                    } else {
                        alert(data.error || 'Nothing to undo');
                    }
                });
            });
            
            // Redo functionality - Fixed to properly repost the message
            redoButton.addEventListener('click', function() {
                fetch('/redo', {
                    method: 'POST',
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Directly submit the undone message to get a new AI response
                        submitMessage(data.user_message);
                    } else {
                        alert(data.error || 'Nothing to redo');
                    }
                });
            });
            
            // Copy full chat functionality
            copyChatButton.addEventListener('click', function() {
                const messages = document.querySelectorAll('.message');
                let fullChatText = '';
                
                messages.forEach(message => {
                    const role = message.querySelector('.message-role').textContent;
                    const content = message.querySelector('.message-content').textContent;
                    fullChatText += `${role}:\n${content}\n\n`;
                });
                
                copyToClipboard(fullChatText.trim());
            });
            
            // Clear chat modal functionality
            clearButton.addEventListener('click', function() {
                clearModal.classList.add('show');
            });
            
            cancelClear.addEventListener('click', function() {
                clearModal.classList.remove('show');
            });
            
            confirmClear.addEventListener('click', function() {
                clearModal.classList.remove('show');
                fetch('/clear', {
                    method: 'POST',
                }).then(() => {
                    window.location.reload();
                });
            });
            
            // Close modal when clicking outside
            clearModal.addEventListener('click', function(e) {
                if (e.target === clearModal) {
                    clearModal.classList.remove('show');
                }
            });
            
            // Copy text to clipboard
            function copyToClipboard(text) {
                navigator.clipboard.writeText(text).then(function() {
                    // Temporary feedback
                    const originalText = copyChatButton.textContent;
                    copyChatButton.textContent = '‚úÖ Copied!';
                    setTimeout(() => {
                        copyChatButton.textContent = originalText;
                    }, 2000);
                }).catch(function(err) {
                    console.error('Could not copy text: ', err);
                });
            }
            
            // Auto-scroll to bottom of chat history
            let shouldAutoScroll = true;
            let userHasScrolled = false;
            
            // Listen for user scroll events
            chatHistory.addEventListener('scroll', function() {
                userHasScrolled = true;
                const isAtBottom = chatHistory.scrollHeight - chatHistory.clientHeight <= chatHistory.scrollTop + 20;
                shouldAutoScroll = isAtBottom;
            });
            
            function scrollToBottom() {
                if (shouldAutoScroll && !userHasScrolled) {
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                }
            }
            
            scrollToBottom();
            
            // Auto-resize textarea based on content
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = (this.scrollHeight) + 'px';
            });
            
            // Handle Enter key to submit (Shift+Enter for new line)
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (textarea.value.trim() !== '') {
                        submitForm();
                    }
                }
            });
            
            // Handle form submission
            chatForm.addEventListener('submit', function(e) {
                e.preventDefault();
                if (textarea.value.trim() !== '') {
                    submitForm();
                }
            });
            
            // Submit form via AJAX with streaming support
            function submitForm() {
                const userMessage = textarea.value;
                // Don't clear textarea here - do it after adding message to chat
                submitMessage(userMessage);
            }
            
            function submitMessage(userMessage) {
                // When a new message is sent, reset scrolling behavior
                shouldAutoScroll = true;
                userHasScrolled = false;
                
                // Hide welcome message when first message is sent
                const welcomeMessage = document.getElementById('welcome-message');
                if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
                
                // Show loading state
                button.disabled = true;
                button.classList.add('loading');
                buttonText.textContent = 'Sending...';
                spinner.style.display = 'inline-block';
                
                // Add user message to chat history FIRST
                addMessageToChat('user', userMessage);
                
                // THEN clear the textarea and reset its height
                textarea.value = '';
                textarea.style.height = 'auto';
                
                // Create a placeholder for the bot response with cursor
                const botMessageDiv = document.createElement('div');
                botMessageDiv.className = 'message bot-message';
                
                const roleDiv = document.createElement('div');
                roleDiv.className = 'message-role';
                roleDiv.textContent = 'Kambot';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = '<span class="typing">|</span>';
                
                // Add thinking indicator for reasoning models
                const thinkingIndicatorDiv = document.createElement('div');
                thinkingIndicatorDiv.className = 'thinking-indicator';
                thinkingIndicatorDiv.innerHTML = '<span class="thinking-emoji">ü§î</span> Thinking...';
                
                botMessageDiv.appendChild(roleDiv);
                botMessageDiv.appendChild(thinkingIndicatorDiv);
                botMessageDiv.appendChild(contentDiv);
                
                chatHistory.insertBefore(botMessageDiv, thinkingIndicator);
                thinkingIndicator.style.display = 'none';
                
                scrollToBottom();
                
                // First, send the initial POST request
                fetch('/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: 'user_query=' + encodeURIComponent(userMessage)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.streaming) {
                        return fetch('/stream', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ message_id: data.message_id })
                        }).then(response => {
                            const reader = response.body.getReader();
                            const decoder = new TextDecoder();
                            let thinkingSection = null;
                            let thinkingContent = null;
                            
                            function processStream() {
                                return reader.read().then(({ done, value }) => {
                                    if (done) {
                                        // Hide thinking indicator and just remove the typing cursor
                                        thinkingIndicatorDiv.style.display = 'none';
                                        thinkingIndicatorDiv.classList.remove('show');
                                        // Remove the typing cursor without reformatting
                                        const currentContent = contentDiv.innerHTML;
                                        if (currentContent.includes('<span class="typing">|</span>')) {
                                            contentDiv.innerHTML = currentContent.replace('<span class="typing">|</span>', '');
                                        }
                                        resetButtonState();
                                        return;
                                    }
                                    
                                    const chunk = decoder.decode(value);
                                    const lines = chunk.split('\n\n');
                                    
                                    for (const line of lines) {
                                        if (line.startsWith('data: ')) {
                                            try {
                                                const eventData = JSON.parse(line.substring(6));
                                                
                                                if (eventData.error) {
                                                    thinkingIndicatorDiv.style.display = 'none';
                                                    thinkingIndicatorDiv.classList.remove('show');
                                                    contentDiv.innerHTML = formatMessage(eventData.full);
                                                    resetButtonState();
                                                    return;
                                                }
                                                
                                                const wasAtBottom = !userHasScrolled || 
                                                    (chatHistory.scrollHeight - chatHistory.clientHeight <= chatHistory.scrollTop + 20);
                                                
                                                // Handle reasoning models
                                                if (eventData.is_reasoning) {
                                                    // Show/hide thinking indicator based on thinking state
                                                    if (eventData.is_thinking) {
                                                        thinkingIndicatorDiv.style.display = 'flex';
                                                        thinkingIndicatorDiv.classList.add('show');
                                                    } else {
                                                        thinkingIndicatorDiv.style.display = 'none';
                                                        thinkingIndicatorDiv.classList.remove('show');
                                                    }
                                                    
                                                    // Create or update thinking section
                                                    if (eventData.thinking && !thinkingSection) {
                                                        thinkingSection = createThinkingSection();
                                                        botMessageDiv.insertBefore(thinkingSection, contentDiv);
                                                        thinkingContent = thinkingSection.querySelector('.thinking-content');
                                                        // No need to manually attach handlers - event delegation handles it
                                                    }
                                                
                                                    // Update thinking content
                                                    if (thinkingContent && eventData.thinking) {
                                                        thinkingContent.textContent = eventData.thinking;
                                                    }
                                                
                                                    // Update main content - formatting is already applied by server
                                                    contentDiv.innerHTML = formatMessage(eventData.full) + '<span class="typing">|</span>';
                                                } else {
                                                    // Regular model - hide thinking indicator immediately
                                                    thinkingIndicatorDiv.style.display = 'none';
                                                    thinkingIndicatorDiv.classList.remove('show');
                                                    // Update content - formatting is already applied by server
                                                    contentDiv.innerHTML = formatMessage(eventData.full) + '<span class="typing">|</span>';
                                                }
                                                
                                                if (wasAtBottom) {
                                                    chatHistory.scrollTop = chatHistory.scrollHeight;
                                                }
                                            } catch (e) {
                                                console.error('Error parsing SSE data:', e);
                                            }
                                        }
                                    }
                                    
                                    return processStream();
                                });
                            }
                            
                            return processStream();
                        });
                    } else {
                        thinkingIndicatorDiv.style.display = 'none';
                        thinkingIndicatorDiv.classList.remove('show');
                        contentDiv.textContent = data.response;
                        resetButtonState();
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    thinkingIndicatorDiv.style.display = 'none';
                    thinkingIndicatorDiv.classList.remove('show');
                    contentDiv.textContent = 'Sorry, an error occurred. Please try again. üòÖ';
                    resetButtonState();
                });
            }
            
            // --- Add event delegation for thinking toggle clicks ---
            chatHistory.addEventListener('click', function(e) {
                const toggle = e.target.closest('.thinking-toggle');
                if (toggle) {
                    e.preventDefault();
                    e.stopPropagation();
                    const content = toggle.parentElement.querySelector('.thinking-content');
                    const caret = toggle.querySelector('.thinking-caret');
                    if (content && caret) {
                        if (content.classList.contains('expanded')) {
                            content.classList.remove('expanded');
                            caret.classList.remove('expanded');
                            caret.textContent = '‚ñ∂';
                            caret.style.transform = 'rotate(0deg)';
                        } else {
                            content.classList.add('expanded');
                            caret.classList.add('expanded');
                            caret.textContent = '‚ñ∂';
                            caret.style.transform = 'rotate(90deg)';
                        }
                    }
                }
            });
            
            // Format existing bot messages on page load - fix timing and prevent double-formatting
            function formatExistingMessages() {
                const existingBotMessages = document.querySelectorAll('.message-content[data-formatted="true"]');
                existingBotMessages.forEach((messageElement) => {
                    // Only format if not already formatted (avoid double-formatting)
                    if (!messageElement.hasAttribute('data-formatted-processed')) {
                        const rawText = messageElement.textContent;
                        // Remove any <think> tags and their content for display
                        const cleanText = rawText.replace(/<think>.*?<\/think>/gs, '');
                        messageElement.innerHTML = formatMessage(cleanText);
                        messageElement.setAttribute('data-formatted-processed', 'true');
                    }
                });

                // Hide all thinking-content by default on page load
                const allThinkingContents = document.querySelectorAll('.thinking-content');
                allThinkingContents.forEach(content => {
                    content.classList.remove('expanded');
                });
            }

            // Call formatting after a small delay to ensure DOM is ready
            setTimeout(formatExistingMessages, 100);
            // Also call immediately for faster initial load
            formatExistingMessages();

            // Remove all per-toggle click handler setup in initializeThinkingSections
            function initializeThinkingSections() {
                const allThinkingSections = document.querySelectorAll('.thinking-section');
                allThinkingSections.forEach((section) => {
                    const toggle = section.querySelector('.thinking-toggle');
                    const caret = toggle ? toggle.querySelector('.thinking-caret') : null;
                    const content = section.querySelector('.thinking-content');
                    if (caret) {
                        caret.style.color = '#ffffff';
                        caret.style.fontSize = '14px';
                        caret.style.fontWeight = 'bold';
                        caret.textContent = '‚ñ∂';
                        caret.classList.remove('expanded');
                    }
                    if (content) {
                        content.classList.remove('expanded');
                        content.style.display = 'block';
                    }
                    // Remove any textContent replacement or formatting here!
                });
            }

            // Initialize thinking sections
            initializeThinkingSections();
            
            function createThinkingSection() {
                const thinkingSection = document.createElement('div');
                thinkingSection.className = 'thinking-section';

                const thinkingToggle = document.createElement('div');
                thinkingToggle.className = 'thinking-toggle';
                thinkingToggle.innerHTML = '<span class="thinking-caret" style="color: #ffffff; font-size: 14px; font-weight: bold;">‚ñ∂</span>';

                const thinkingContent = document.createElement('div');
                thinkingContent.className = 'thinking-content';
                thinkingContent.style.display = 'block';

                thinkingSection.appendChild(thinkingToggle);
                thinkingSection.appendChild(thinkingContent);

                // No click handler setup here!
                return thinkingSection;
            }

            function addMessageToChat(role, content) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role === 'user' ? 'user-message' : 'bot-message'}`;
                
                const roleDiv = document.createElement('div');
                roleDiv.className = 'message-role';
                roleDiv.textContent = role === 'user' ? 'You' : 'Kambot';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                // Check if this is a bot message with reasoning (contains <think> tags)
                if ((role === 'assistant' || role === 'bot') && content.includes('<think>')) {
                    // Extract thinking content
                    const thinkMatches = content.match(/<think>(.*?)<\/think>/gs);
                    const thinkingText = thinkMatches ? thinkMatches.map(match => match.replace(/<\/?think>/g, '')).join('\n') : '';
                    
                    // Extract main content (everything outside <think> tags)
                    const mainContent = content.replace(/<think>.*?<\/think>/gs, '').trim();
                    
                    // Add thinking section if there's thinking content
                    if (thinkingText) {
                        const thinkingSection = createThinkingSection();
                        const thinkingContentDiv = thinkingSection.querySelector('.thinking-content');
                        thinkingContentDiv.textContent = thinkingText;
                        messageDiv.appendChild(roleDiv);
                        messageDiv.appendChild(thinkingSection);
                    } else {
                        messageDiv.appendChild(roleDiv);
                    }
                    
                    contentDiv.innerHTML = formatMessage(mainContent);
                } else {
                    messageDiv.appendChild(roleDiv);
                    // Format the content if it's from the bot
                    if (role === 'assistant' || role === 'bot') {
                        contentDiv.innerHTML = formatMessage(content);
                    } else {
                        contentDiv.textContent = content;
                    }
                }
                
                messageDiv.appendChild(contentDiv);
                
                chatHistory.insertBefore(messageDiv, thinkingIndicator);
                scrollToBottom();
                
                if (role === 'user') {
                    userHasScrolled = false;
                    shouldAutoScroll = true;
                }
            }
            
            // Function to format markdown-style text
            function formatMessage(text) {
                // Escape HTML first
                let formatted = text.replace(/&/g, '&amp;')
                                  .replace(/</g, '&lt;')
                                  .replace(/>/g, '&gt;');
                
                // Handle ***bold italic*** (must come before ** and *)
                formatted = formatted.replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>');
                
                // Handle **bold**
                formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                
                // Handle *italic*
                formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
                
                // Handle [color:text] formatting
                formatted = formatted.replace(/\[red:(.*?)\]/g, '<span class="color-red">$1</span>');
                formatted = formatted.replace(/\[green:(.*?)\]/g, '<span class="color-green">$1</span>');
                formatted = formatted.replace(/\[blue:(.*?)\]/g, '<span class="color-blue">$1</span>');
                formatted = formatted.replace(/\[yellow:(.*?)\]/g, '<span class="color-yellow">$1</span>');
                formatted = formatted.replace(/\[purple:(.*?)\]/g, '<span class="color-purple">$1</span>');
                formatted = formatted.replace(/\[orange:(.*?)\]/g, '<span class="color-orange">$1</span>');
                formatted = formatted.replace(/\[pink:(.*?)\]/g, '<span class="color-pink">$1</span>');
                formatted = formatted.replace(/\[cyan:(.*?)\]/g, '<span class="color-cyan">$1</span>');
                formatted = formatted.replace(/\[lime:(.*?)\]/g, '<span class="color-lime">$1</span>');
                formatted = formatted.replace(/\[teal:(.*?)\]/g, '<span class="color-teal">$1</span>');
                
                return formatted;
            }
            
            function resetButtonState() {
                button.disabled = false;
                button.classList.remove('loading');
                buttonText.textContent = 'Send';
                spinner.style.display = 'none';
            }
            
            // Helper function to update button text
            function updateButtonText(button, isEnabled, enabledText, disabledText) {
                button.textContent = isEnabled ? enabledText : disabledText;
            }
            
            // Enhanced status update function with visual feedback
            function updateStatusIndicator(statusElement, isEnabled) {
                if (!statusElement) {
                    console.error('Status element not found');
                    return;
                }
                
                // Add flash effect to show the change
                statusElement.style.transition = 'all 0.2s ease';
                statusElement.style.transform = 'scale(1.1)';
                
                statusElement.textContent = isEnabled ? 'ON' : 'OFF';
                statusElement.className = isEnabled ? 'button-status status-on' : 'button-status status-off';
                
                // Reset scale after animation
                setTimeout(() => {
                    statusElement.style.transform = 'scale(1)';
                }, 200);
                
                console.log(`Updated ${statusElement.id}: ${isEnabled ? 'ON' : 'OFF'}`);
            }
            
            // Emoji toggle functionality with immediate feedback
            if (emojiToggleButton) {
                emojiToggleButton.addEventListener('click', function() {
                    emojisEnabled = !emojisEnabled;
                    updateStatusIndicator(emojiStatus, emojisEnabled);
                    
                    console.log(`Emoji button clicked - new state: ${emojisEnabled}`);
                    
                    fetch('/set_emoji_mode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ emojis_enabled: emojisEnabled })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Emoji setting response:', data);
                        if (!data.success) {
                            console.error('Failed to update emoji setting:', data.error);
                            emojisEnabled = !emojisEnabled;
                            updateStatusIndicator(emojiStatus, emojisEnabled);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating emoji setting:', error);
                        emojisEnabled = !emojisEnabled;
                        updateStatusIndicator(emojiStatus, emojisEnabled);
                    });
                });
            }
            
            // Color toggle functionality with immediate feedback
            if (colorToggleButton) {
                colorToggleButton.addEventListener('click', function() {
                    colorsEnabled = !colorsEnabled;
                    updateStatusIndicator(colorStatus, colorsEnabled);
                    
                    console.log(`Color button clicked - new state: ${colorsEnabled}`);
                    
                    fetch('/set_color_mode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ colors_enabled: colorsEnabled })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Color setting response:', data);
                        if (!data.success) {
                            console.error('Failed to update color setting:', data.error);
                            colorsEnabled = !colorsEnabled;
                            updateStatusIndicator(colorStatus, colorsEnabled);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating color setting:', error);
                        colorsEnabled = !colorsEnabled;
                        updateStatusIndicator(colorStatus, colorsEnabled);
                    });
                });
            }

            // Bold toggle functionality with immediate feedback
            if (boldToggleButton) {
                boldToggleButton.addEventListener('click', function() {
                    boldEnabled = !boldEnabled;
                    updateStatusIndicator(boldStatus, boldEnabled);
                    
                    console.log(`Bold button clicked - new state: ${boldEnabled}`);
                    
                    fetch('/set_bold_mode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ bold_enabled: boldEnabled })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Bold setting response:', data);
                        if (!data.success) {
                            console.error('Failed to update bold setting:', data.error);
                            boldEnabled = !boldEnabled;
                            updateStatusIndicator(boldStatus, boldEnabled);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating bold setting:', error);
                        boldEnabled = !boldEnabled;
                        updateStatusIndicator(boldStatus, boldEnabled);
                    });
                });
            }

            // Italic toggle functionality with immediate feedback
            if (italicToggleButton) {
                italicToggleButton.addEventListener('click', function() {
                    italicsEnabled = !italicsEnabled;
                    updateStatusIndicator(italicStatus, italicsEnabled);
                    
                    console.log(`Italic button clicked - new state: ${italicsEnabled}`);
                    
                    fetch('/set_italic_mode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ italics_enabled: italicsEnabled })
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Italic setting response:', data);
                        if (!data.success) {
                            console.error('Failed to update italic setting:', data.error);
                            italicsEnabled = !italicsEnabled;
                            updateStatusIndicator(italicStatus, italicsEnabled);
                        }
                    })
                    .catch(error => {
                        console.error('Error updating italic setting:', error);
                        italicsEnabled = !italicsEnabled;
                        updateStatusIndicator(italicStatus, italicsEnabled);
                    });
                });
            }
        });
    </script>
    <script>
        // Remove the global toggleThinking function, as event delegation now handles all toggles
    </script>
</body>
</html>
